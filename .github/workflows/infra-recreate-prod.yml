name: Recreate Prod (CDKTF)

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: "Type RECREATE to confirm you want to destroy and recreate the prod environment"
        required: true
        type: string
      fresh_db:
        description: "Reset PostgreSQL database (DROP/CREATE) before recreation - DESTROYS ALL DATA"
        required: false
        default: "false"
        type: choice
        options: ["false", "true"]

jobs:
  recreate:
    runs-on: ubuntu-latest
    environment:
      name: gridpulse/prod
    env:
      TF_CLOUD_ORG: ${{ secrets.TF_CLOUD_ORG }}
      TF_CLOUD_WORKSPACE: gridpulse-prod
      TF_TOKEN_app_terraform_io: ${{ secrets.TF_API_TOKEN }}
    steps:
      - name: Guard confirmation
        run: |
          if [ "${{ github.event.inputs.confirm }}" != "RECREATE" ]; then
            echo "Confirmation mismatch. Type RECREATE exactly to proceed." >&2
            exit 1
          fi

      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.7.5'

      - name: Install sops and age
        run: |
          sudo apt-get update
          sudo apt-get install -y age
          SOPS_VERSION=v3.8.1
          curl -Ls https://github.com/getsops/sops/releases/download/$SOPS_VERSION/sops-$SOPS_VERSION.linux.amd64 -o sops
          sudo install -m 0755 sops /usr/local/bin/sops

      - name: Decrypt tfvars (required)
        env:
          AGE_PRIVATE_KEY: ${{ secrets.AGE_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          mkdir -p ~/.config/sops/age
          if [ -z "${AGE_PRIVATE_KEY:-}" ]; then
            echo "AGE_PRIVATE_KEY not set; can't decrypt prod.enc.tfvars" >&2
            exit 1
          fi
          printf "%s\n" "$AGE_PRIVATE_KEY" > ~/.config/sops/age/keys.txt
          if [ ! -f secrets/prod.enc.tfvars ]; then
            echo "secrets/prod.enc.tfvars not found. Commit encrypted tfvars first." >&2
            exit 1
          fi
          echo "Decrypting prod.enc.tfvars ‚Üí infrastructure/cdktf/terraform.tfvars"
          sops -d secrets/prod.enc.tfvars > infrastructure/cdktf/terraform.tfvars

      - name: Install CDKTF deps
        working-directory: infrastructure/cdktf
        run: |
          npm ci
          npm run get
          npm run compile

      - name: Synthesize stack (cdktf synth)
        working-directory: infrastructure/cdktf
        run: npx cdktf synth

      - name: Reset database via Railway API (fresh_db=true)
        if: github.event.inputs.fresh_db == 'true'
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
        run: |
          set -euo pipefail
          echo "üóÑÔ∏è Resetting PostgreSQL database via Railway GraphQL API..."
          
          # First, get the environment and postgres service IDs
          echo "üìã Getting project information..."
          PROJECT_QUERY='{
            "query": "query GetProject($projectId: String!) { project(id: $projectId) { environments(first: 10) { edges { node { id name services(first: 20) { edges { node { id name } } } } } } } }",
            "variables": { "projectId": "10593acb-4a7a-4331-a993-52d24860d1fa" }
          }'
          
          PROJECT_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $RAILWAY_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$PROJECT_QUERY" \
            "https://backboard.railway.app/graphql")
          
          echo "Project response: $PROJECT_RESPONSE"
          
          # Extract prod environment ID and postgres service ID
          PROD_ENV_ID=$(echo "$PROJECT_RESPONSE" | jq -r '.data.project.environments.edges[] | select(.node.name == "prod") | .node.id')
          POSTGRES_SERVICE_ID=$(echo "$PROJECT_RESPONSE" | jq -r '.data.project.environments.edges[] | select(.node.name == "prod") | .node.services.edges[] | select(.node.name == "postgres") | .node.id')
          
          if [ -z "$PROD_ENV_ID" ] || [ "$PROD_ENV_ID" = "null" ]; then
            echo "‚ùå Could not find prod environment"
            exit 1
          fi
          
          if [ -z "$POSTGRES_SERVICE_ID" ] || [ "$POSTGRES_SERVICE_ID" = "null" ]; then
            echo "‚ùå Could not find postgres service"
            exit 1
          fi
          
          echo "‚úÖ Found prod environment: $PROD_ENV_ID"
          echo "‚úÖ Found postgres service: $POSTGRES_SERVICE_ID"
          
          # Execute database reset commands directly via Railway API
          echo "üìã Executing database reset commands via Railway API..."
          
          # Get current deployment ID for the postgres service
          DEPLOYMENT_QUERY='{
            "query": "query GetDeployment($environmentId: String!, $serviceId: String!) { deployments(first: 1, input: { environmentId: $environmentId, serviceId: $serviceId, status: SUCCESS }) { edges { node { id status } } } }",
            "variables": { "environmentId": "'$PROD_ENV_ID'", "serviceId": "'$POSTGRES_SERVICE_ID'" }
          }'
          
          DEPLOYMENT_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $RAILWAY_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$DEPLOYMENT_QUERY" \
            "https://backboard.railway.app/graphql")
          
          echo "Deployment response: $DEPLOYMENT_RESPONSE"
          
          DEPLOYMENT_ID=$(echo "$DEPLOYMENT_RESPONSE" | jq -r '.data.deployments.edges[0].node.id // empty')
          
          if [ -z "$DEPLOYMENT_ID" ] || [ "$DEPLOYMENT_ID" = "null" ]; then
            echo "‚ùå Could not find active deployment for postgres service"
            exit 1
          fi
          
          echo "‚úÖ Found deployment: $DEPLOYMENT_ID"
          
          # Execute DROP DATABASE command
          echo "üóëÔ∏è  Dropping existing railway database..."
          
          DROP_EXEC_QUERY='{
            "query": "mutation ServiceInstanceExec($deploymentId: String!, $command: String!) { serviceInstanceExec(deploymentId: $deploymentId, command: $command) { exitCode output error } }",
            "variables": { 
              "deploymentId": "'$DEPLOYMENT_ID'",
              "command": "psql -U postgres -d postgres -c \"DROP DATABASE IF EXISTS railway;\""
            }
          }'
          
          DROP_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $RAILWAY_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$DROP_EXEC_QUERY" \
            "https://backboard.railway.app/graphql")
          
          echo "Drop database response: $DROP_RESPONSE"
          
          # Execute CREATE DATABASE command  
          echo "üÜï Creating fresh railway database..."
          
          CREATE_EXEC_QUERY='{
            "query": "mutation ServiceInstanceExec($deploymentId: String!, $command: String!) { serviceInstanceExec(deploymentId: $deploymentId, command: $command) { exitCode output error } }",
            "variables": { 
              "deploymentId": "'$DEPLOYMENT_ID'",
              "command": "psql -U postgres -d postgres -c \"CREATE DATABASE railway;\""
            }
          }'
          
          CREATE_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $RAILWAY_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$CREATE_EXEC_QUERY" \
            "https://backboard.railway.app/graphql")
          
          echo "Create database response: $CREATE_RESPONSE"
          
          # Check if commands were successful
          DROP_EXIT_CODE=$(echo "$DROP_RESPONSE" | jq -r '.data.serviceInstanceExec.exitCode // 1')
          CREATE_EXIT_CODE=$(echo "$CREATE_RESPONSE" | jq -r '.data.serviceInstanceExec.exitCode // 1')
          
          if [ "$DROP_EXIT_CODE" -eq 0 ] && [ "$CREATE_EXIT_CODE" -eq 0 ]; then
            echo "‚úÖ Database successfully reset via Railway API"
          else
            echo "‚ö†Ô∏è  Database reset may have had issues, but proceeding with infrastructure recreation"
            echo "Drop exit code: $DROP_EXIT_CODE"
            echo "Create exit code: $CREATE_EXIT_CODE"
          fi
          
          echo "‚úÖ Database reset complete - infrastructure recreation will use new password"

      - name: Terraform init + destroy
        working-directory: infrastructure/cdktf
        env:
          TF_IN_AUTOMATION: "true"
        run: |
          set -euo pipefail
          # Place tfvars next to synthesized stack
          cp -f terraform.tfvars cdktf.out/stacks/gridpulse-prod/terraform.tfvars
          terraform -chdir=cdktf.out/stacks/gridpulse-prod init -input=false -no-color
          # If fresh_db=true, explicitly destroy the postgres service first to ensure a clean data directory
          if [ "${{ github.event.inputs.fresh_db }}" = "true" ]; then
            echo "Forcing Postgres destroy first (fresh_db=true)..."
            terraform -chdir=cdktf.out/stacks/gridpulse-prod destroy -target=railway_service.postgres -auto-approve -input=false -no-color || true
            echo "Also destroying environment to guarantee new service resources (will recreate)..."
            terraform -chdir=cdktf.out/stacks/gridpulse-prod destroy -target=railway_environment.environment -auto-approve -input=false -no-color || true
          fi
          terraform -chdir=cdktf.out/stacks/gridpulse-prod destroy -auto-approve -input=false -no-color || true

      - name: Terraform apply (recreate)
        working-directory: infrastructure/cdktf
        env:
          TF_IN_AUTOMATION: "true"
        run: |
          set -euo pipefail
          # After destroy, ensure init (no-op if already initialized)
          terraform -chdir=cdktf.out/stacks/gridpulse-prod init -input=false -no-color
          terraform -chdir=cdktf.out/stacks/gridpulse-prod apply -auto-approve -input=false -no-color
